1. 入门(092)
    anaconda3.5.3版本的安装和简介
    jupyter的使用
        shift + Enter : 从当前行向下顺序执行python指令
        Ctrl + Enter : 只执行当行python指令

2. 数据类型(093)
    type(变量或常量或有返回值的表达式) 函数: 查看数据类型的函数

    运算符 /  与 //  , 前者运算结束是完全除,即可得到实际结果, 后者是整除, 只获得整数结果值.

    运算符 % , 是求模运算, 即只获取两个操作数相除的余数

    单/双引号: 都表示字符串, 同时存在的意义是嵌套应用, 多外双内单.

    三引号: 当一个字符串中即有单引号, 又有双引号, 且有换行操作时, 可以使用此三引号

    转义符: \

    print() 函数输出字符串时, 不会输出字符串两端的引号的

3. 变量(094)
    批量初始化变量:  a,b,c = 1,2,3
    给变量赋空值: x = None
    数据的平方: a**2

4. 列表(095)
    list1=[1,2,3,4]
    列表求和: sum(list1)
    列表长度: len(list1)
    插入元素: list1.insert(位置, 值)
    添加元素: list1.append(值)
    添加多个元素: list1 = list1 + [5,6,7]
    弹出/删除元素: list1.pop(元素值), 不指定元素, 默认删除最后一个元素
    修改元素值: list1[索引]=新值

    索引列表元素: list1[0] , 默认列表的第一个元素的索引编号是 0
    列表切片: list1[0:2] , 从列表第一个元素到第2-1位置的元素, 即: 1,2 两个元素
    列表可以存在重复的元素

5. 列表进阶(096)
    多维列表: x = [[1,2,3],[4,5,6]] , 两行三列
    获取某个元素: x[0][1]
    快速创建列表: x = [12]*4 , 结果: [12,12,12,12]
    快速创建多维: x = [x]*3, 结果:[[12,12,12,12],[12,12,12,12],[12,12,12,12],[12,12,12,12]]

6. 字典(097)
    元组: x = (1,2,3)
    元组元素不能被修改: x[2] = 4 是错误的操作
    其它方面元组类似列表

    字典: x = {'a':1, 'b':3, 'c':4, 'd':5} 键值对的集合
    常用key做为索引: x['a']
    字典是无序的

    字典函数:
    x.get(key, 为空时返回的值) #如果返回结果为空时, 则返回指定的值
    x.setDefault(key, value)  #有则返回, 没有则添加此键值对
    x.keys()
    x.vlaues()
    x.items()
    字典的交集, 并集, 差集 同样要先转换为集合后操作

    所属判断: in, 判断一个元素是否属于一个列表, 元组, 字典

7. 集合(098)
    集合: {1,2,3,4}
    集合不允许存在重复项
    集合不能直接进行索引, 必先转换在列表后再进行索引操作
    集合取交集:
        a = [1,2,3]
        b = [2,3,4]
        set(a) & set(b) #取交集
        {2,3}
        set(a) | set(b) #取并集
        {1,2,3,4}
        set(a) - set(b) #取差集
        {1}

8. 控制流(099)
    a = 10
    if  a>5:
        打印条件为真时的结果
    else:
        打印条件为假时的结果

9. 控制循环流(100)
    count=0
    while count<10:
        print(count)
        count = count + 1

    循环中常用的break(终止循环), continue(跳过当次循环进入下次循环)
    pass 语句是个空语句, 语句占位符

    for i in range(10):
        print(i)

    for k,v in dict.items():
        print(k)
        print(v)

10. 循环进阶(101)
    python优雅的写法:
    [i for i in range(1,101) if i%2==0]
    等价于:
    list=[]
    for i in range(1,101):
        if i%2 == 0:
            list.append(i)

11. python函数(102)
    使用 def 定义函数
    def func(x):
        函数体语句集合

    定义函数
    def func(x):
        if(x>10):
            print('more than 10')
        else:
            print('less than 10')

    func(1)  #调用函数

    函数参数的默认值

12. 高阶函数(103)
    优雅函数: [i**2 for i in range(1,10)]
    还可以:
    def func(x):
        return x*x

    [frunc(i) for i in range(1,10)]

    map(func, 可变参数)
    map(func, [1,2,3,4,5])

    list(map(func, [1,2,3,4,5]))  #结果等价于 [frunc(i) for i in range(1,10)]

    a=[1,2,3,4,5]
    list(map(str, map(func, a))) #可嵌套使用

    匿名函数:
    lambda x:x*x
    list(map(lambda x:x*x, [1,2,3,4])) #免去定义函数的烦琐
    还可以嵌套一些系统内置函数, 比如 str , 转化为字符串类型
    list(map(lambda x:str(x), [1,2,3,4]))

13. 第三方包(104)
    import collections
        .Counter(list对象)  #用来计数统计, 以字典对象输出
    import csv #csv文件读写编辑
    import datetime #日期时间
    import math  #数学
    import pandas
    import numpy #数据分析相关的两个库

14. numpy(105)
    import numpy as np
    数组: a=np.array([1,2,3,4,5])
        可以将列表转化为数组
        a的数据类型 type(a) , numpy.ndarray 类型
        a+1 相当于数组的每个元素+1
        a*2
        a**2

        b=np.array([1,2,4],[2,3,4],[5,6,7],[7,8,9])
        b就是一个多维数组了, 也可以称为4*3的一个矩阵

        也可以通过b这个多维数组进行切片
        b[0]  结果就是 array([1,2,4])

        查看b数组中的数据类型: b.dtype()  , 结果: dtype('int32')
        而: type(1) 的数据类型是 int
        两种数据类型是区别的, 有时是需要转换的

        numpy 本身使用的就是数组结构

15. Pandas series (106) 索引列表
    import pandas as pd
    pandas 有两个数据结构 series(基础) 和 dataframe
    s=pd.Series([1,2,3,4])
    s的打印结果: 前者是索引,后者是数据元素
        0  1
        1  2
        2  3
        3  4
        dtype: int64
    s.index 可以打印出索引相关信息
        RangeIndex(start=0, stop=4, step=1)

    切片: s[1]  结果: 2

    s1=pd.Series([1,2,3,4], index=['a', 'b', 'c', 'd'])  结果索引被修改
        a  1
        b  2
        c  3
        d  4
        dtype: int64
    切片: s1['a']   结果: 1

    转换s1内元素的数据类型为 字符串
    s1.astype('str')  这样就转换成字符串对象
        a  1
        b  2
        c  3
        d  4
        dtype: object

    另一种转换数据类型的方式就是得用索引列表中类型必须是统一的,
    可以在s1对象中添加一个字符串元素: s1['A']='a'
    这样子的话, dtype: object 就自动转移为字符串对象

    多元素索引需要使用列表:
    s1[  ['a', 'c'] ] 结果:
        a  1
        c  3

    增加元素: 也可以修改元素
    s1['d'] = 5 , 这样s1对象中就增加了一个元素

    可以与字典互换
    d = {'a':'ok', 'b':'yes'}
    s2=pd.Series(d) 打印结果
        a  ok
        b  yes
        dtype: object

    强制为字典增加一个索引:
    s2 = pd.Series(d.index=['a', 'b', 'c'])  打印结果
        a  ok
        b  yes
        c  NaN
        dtype: object

16. Pandas dataframe (107)
    pd.DataFrame 是一个数据框
    而 pd.DataFrame([1,2,4,5])  生成的不是表格, 必须再执行一次
    pd.DataFrame(s) 将前的结果转换成表格形式
    但是如果pd.DataFrame([[1,2,3,4],[6,7,8,9]])  包含的是多维列表的话
    生成的就是一个表格了
    同样是使用index自定义行标签, column定义列标签, 两个参数都是列表

    x = pd.DataFrame({'a':[1,2,3,4],'b':[6,7,8,9]})
    x.info() 可获取表格的数据类型信息

    对DataFrame进行切片后, 会转换为 Series, 但是切多列的话仍是表格形式
    切片的方式可以 x['a'] 也可以是 x.a 的方式 (这是对列的切片)
    也可以对行进行切片 x.ix[0] 取0行

17. Python dataframe查找 (108)
    如: 查找age列中年龄==18的数据
    df[  df.age==18 ]  注意是两个等号, 在此基础上再切片 df[  df.age==18 ] .age
    也可 df[  ~df.age>19 ]  也可以对条件进行取反操作, 即查找 df.age<=18 的数据
    也可以多条件: df[  (df.age==18)&(df.name=='abc') ]

    另一种查询方式:
    df.query("(age==18) & (sex=='male')")

    df.iloc[1] 查询第1行数据, 是根据行编号查询
    df[1] 这种写法是错误的, df[0:1] 这样查询就是第0行数据
    df.iloc[行, 列], 如: df[1:2, 1:2] 这里是以数字进行切片的, 与行列标签名无关

    df.loc['a'] 查询 行标签为 a 的行数据, 即是根据行标签查询
    df.loc['a', 'age'] 行标签=a, 列标签=age 的交叉点数据
    df.loc['a', ['age', 'name']] 一行多列

    针对某列进行切片
    df.loc[  df.age==19, 'age' ] 查找或获取 age 列中 值是19的数据, 打印结果:
        a  19
        b  19
        Name: age, dtype: int64

    用上面方式查找的结果可以直接修改值: df.loc[  df.age==19, 'age' ] = 20

18. read_csv (109)
    import pandas as pd
    pd.read_csv('xxxxx.csv')  //前提是csv文件与脚本在同一目录下,默认是udf8解析
    pd.read_csv('xxxxx.csv', encoding='gbk') //原文件是GBK就需要添加这个参数, 但是分隔符是 '\t' , 所以需要指定分隔符
    pd.read_csv('xxxxx.csv', encoding='gbk', sep='\t', names=list('abcdefg'))  //names参数是可以指定列名的, 文档原有列名被定义为第0行数据.

    df = pd.read_csv('xxxxx.csv', encoding='gbk', sep='\t')
    df.info() //用于显示数据信息概览

    df.head() //只打印数据的前5行数据
    df.head(20) //则是打印前20行
    df.tail() //打印后5行数据
    df.tail(20) //打印后20行数据

    df.top.astype('str') //将top列的数据转换数据类型为字符串, 但这样子是不会改变原有数据类型的, 必须将这个改变后的类型赋值到表中对应的列才行
    df.top = df.top.astype('str')

    df[ (df.city == '上海') & (df.avg > 15) ] 多条件查询

19. 计算 (110)
    df.T   //这个是将原有表结构进行转置, 即行列数据互换
    df.sort_values(by='avg') //按avg列进行升序排序, 返回的仍然是数组结构
    df.avg.sort_values()   //只返回按升序排序后的 avg 列数组结果
    df.sort_values('avg') //同 by='avg' 的一样结果
    df.sort_values(['avg', 'city'], ascending=False)  //多列按降序排序

    df.sort_index()  //顾名知意, 就是按默认索引的升序排序

    排名 rank
    df.avg.rank() //根据avg的列值进行排名, 默认是升序
    df['rank'] = df.avg.rank() //为数组添加一列按avg排名的排名列值
    df['rank'] = df.avg.rank(ascending=false) //avg列排序按降序排名
    rank 生成排名时, 遇到相同值的数据, 默认是取相同avg值排名中的第一和最后一个的平均值, 所以有 +-0.5 浮动偏差.
    如: avg中是75的值有4个, 4个值的排序是1,2,3,4, 则取 (1+4)/2 = 2.5, 则4个avg=75 的值的排名就是2.5. 这是由 rank函数的method='average' 默认决定的, 当然这个参数是可以修改的.
    df['rank'] = df.avg.rank(ascending=false, method='min')  //同是按avg值第一次出现的排名算, 如: 75这个值第一次出现在排名中是 2, 则后面出的的75这个值都是2.
    df['rank'] = df.avg.rank(ascending=false, method='max')  //同min相反
    df['rank'] = df.avg.rank(ascending=false, method='first')  //不考虑并列的情况, 第几个出现的就是第几名
    df['rank'] = df.avg.rank(ascending=false, method='last')

    去重复 unique
    df.city.unique() //相当于SQL中的Distinct

    计数 value_counts
    df.city.value_counts()

    数据描述 describe()
    df.describe()
        count: 计数
        mean: 平均数
        std: 标准差
        min: 最小值
        25%, 50%, 75% 是分位数
        max: 最大值

    具体到每个字段的数据描述
    df.avg.describe()

    累加函数 cumsum
    df.avg.cumsum() //对avg列进行逐行累加

    分筒函数,bins, 此函数是与DataFrame同级的, 需要使用pd引用
    pd.cut(df.avg, bins=20) //即将avg字段中最小值到最大值进行20等分
    pd.cut(df.avg, bins=4, labels=list('abcd')) //labels参数是用分等级档次
    pd.cut(df.avg, bins=4, include_lowest=True) //include_lowest是否包含最小值
    pd.cut(df.avg, bins=[0, 5, 10, 20, 30, 100], labels=['0~5', '5~10', '10~20', '20~30', '30~100']) //手工分筒分级

20. Python groupby (111)
    df.groupby(by='city').count()  //按城市分组计数
    df.groupby(by='city').max() //按城市分组取每个分组的最大值
    df.groupby(by='city')['avg'].max() //按城市分组取每个分组中avg列的最大值
    df.groupby(by='city').avg.max()  //执行结果同上

    df.groupby(by=['city', 'workYear']).max() //按城市,工作年限进行分组聚合

    for k,v in df.groupby(by='city'):
        print(max(v.avg) - min(v['avg'])) //计算每个城市平均薪资最大值与最小值的差值
        print('**'*10) //打印10个 '**' 符号组成的分隔行

21. Python Pandas关联 (112)
    多表关联操作
    import pandas as pd
    position = pd.read_csv('position_gbk.csv', encoding='gbk')
    company = pd.read_csv('company_utf.csv', encoding='utf')

    三种关联方法: concat(类似SQL中的union), join(相当于SQL的join), merge(常用,默认等值连inner)
    position.merge(right=company, how='inner', left_on='companyId', right_on='id')
    两表联接, 右(right)表是company, 方式how是 inner, 等值条件, 左='companyId', 右='id'.

    也可以使用 pd 下面的merge函数
    pd.merge(左表, 右表, 联接方式, on条件, 右键, 右键, ... ...)

    join默认是基于表的索引进行关联
    company.join(position)

    concat 就是表的拼接或叫堆叠(简单粗暴)
    pd.concat(company, position) //默认是上下拼接
    pd.concat(['company', 'position'].axis=1) //更改为左右拼接
    常用于同结构多表合并操作

22. Python Pandas 多重索引(113)
    position.groupby(by=['city', 'education']).mean().avg['上海']
    position.groupby(by=['city', 'education']).mean()的结果是DataFrame类型,
    position.groupby(by=['city', 'education']).mean().avg 结果是Series类型一维
    所以可以直接单独取出 '上海' 的平均值数据

    position.groupby(by=['city', 'education']).mean().loc['上海']
    DataFrame类型的使用 loc 函数

    position.groupby(by=['city', 'education']).mean().loc['上海', '博士']

    另一种多重索引方式
    position.set_index(['city', 'education'])  //按城市和教育水平索引, 但数据零散
    position.sort_values(by=['city', 'education']).set_index(['city', 'education']) //先排序后的再进行索引, 数据就更加规整了.

    position.groupby(by=['city', 'education']).mean().reset_index()['avg']
    reset_index() 就是将分组列字段补全到每一行中去, 这样也可以根据字段名进行切片

23. Python Pandas 文本函数(114)
    position.positionLables.str //对position数组中的positionLables字段进行字符串处理函数str的使用.
   position.positionLables.str.count('分析师')  //统计每个字符串中 '分析师' 出现的次数
   position.positionLables.str.find('数据') //定位字符串出现的位置
   position.positionLables.str[1:-1] //对字符串进行切片

   DataFrame级别也有replace函数, 主要是对数组中的值进行处理
   position.positionLables.str[1:-1].replace("'","")  //此语句不可行, 切片后的数据是Series的一维数组, 还是需要先调用 str 函数, 变成position.positionLables.str[1:-1].str.replace("'","") 就可以了.

24. Python Pandas 去重(115)
    position.loc[position.city=='深圳', 'city'] //查询深圳城市数据, 只显示city列
    position.fillna(值) //用于填充DataFrame中字段值是 NaN 的字段
    position.city.fillna(值) //只对city列中的 NaN 值进行填充
    position.dropna() //删除存在NaN数据的行
        fillna和dropna函数中的 axis 是轴参数, 默认是0, 针对对象中的所有行, 如果axis=1, 则是针对列操作, 填充列中的NaN空值, 或是删除带有NaN空值的列

    position.duplicated()  //判断数据是否重复
    position[position.duplicated()] //筛选重复值

    实例: s = pd.Series([1,1,2,3,4])
    s.duplicated() //原理就是, 一个数据第一次出现时不是重复数据, 当同一个数据第二次出现是就会被判断为重复数据.
    s[s.duplicated()] //就可以筛选出重复行
    s[~s.duplicated()] //取反就是筛选出不重复的数据
    s.duplicated(keep='first') //判断第一个是非重复数据, 默认值
    s.duplicated(keep='last') //判断最后出现的数据为非重复数据
    s.drop_duplicates() //将去重后的数据返回

25. Python Pandas apply (116)
    position.avg.apply()  //apply函数的作用是将一个功能函数应用到每个值上
    position.avg.apply(lamda x:str(x)+'k') //使用一个匿名函数处理avg列中的每个值
    相当于,先定义一个函数func1
        def func1(x):
            if x>20: return '20+k'
            else: return '0~20k'

        position.avg.apply(func1)

    position对象直接调用, 就不能使用上面那个func1了, 需要进行 列指定
        def func2(x):
            if x.avg>20:
                return '20+k'
            else:
                return '0~20k'

        position.apply(func2, axis=1)  //逐行处理指定的avg列
        position.apply(lambda x:func1(x.avg), axis=1) //如何使用func1函数就这样

26. Python pandas 聚合 apply (117)
    筛选每个城市薪资水平前5的数据:
    def func(x):
        r = x.sort_values('avg', ascending=false)
        return  r[:5]

    position.groupby('city').apply(func)

    更多参数
    def func(x, n, asc=False):
        r = x.sort_values('avg', ascending=asc)
        return  r[:n]
    //查询每个城市, 薪资水平前3的, 排序是升序的数据
    position.groupby('city').apply(func, n=3, asc=True)

    另一个函数 agg
    position.groupby('city').agg(sum) //就可以按城市将数值数据字段进行求和
    position.groupby('city').agg('mean') //求平均
    position.groupby('city').mean() //与上面的求均是等价的

    position.groupby('city').agg(['sum', 'mean']) //也可以应用多个函数功能

    apply 与 agg 的区别是, 数据拆分, agg不能进行数据拆分, 只能生成一行数据
    但agg也是可以使用匿名函数:
    position.groupby('city').agg(lambda x:max(x)-min(x)) //返回的结果一个城市一行数据


















































